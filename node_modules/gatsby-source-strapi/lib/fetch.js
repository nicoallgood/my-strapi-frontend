"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchEntities = exports.fetchEntity = exports.fetchStrapiContentTypes = void 0;

var _lodash = require("lodash");

var _axiosInstance = _interopRequireDefault(require("./axiosInstance"));

var _qs = _interopRequireDefault(require("qs"));

var _cleanData = require("./clean-data");

const fetchStrapiContentTypes = async pluginOptions => {
  const axiosInstance = (0, _axiosInstance.default)(pluginOptions);
  const [{
    data: {
      data: contentTypes
    }
  }, {
    data: {
      data: components
    }
  }] = await Promise.all([axiosInstance.get('/api/content-type-builder/content-types'), axiosInstance.get('/api/content-type-builder/components')]);
  return {
    schemas: [...contentTypes, ...components],
    contentTypes,
    components
  };
};

exports.fetchStrapiContentTypes = fetchStrapiContentTypes;

const fetchEntity = async ({
  endpoint,
  queryParams,
  uid
}, ctx) => {
  const {
    strapiConfig,
    reporter
  } = ctx;
  const axiosInstance = (0, _axiosInstance.default)(strapiConfig);
  const opts = {
    method: 'GET',
    url: endpoint,
    params: queryParams,
    paramsSerializer: params => _qs.default.stringify(params, {
      encodeValuesOnly: true
    })
  };

  try {
    reporter.info(`Starting to fetch data from Strapi - ${opts.url} with ${JSON.stringify(opts)}`);
    const {
      data
    } = await axiosInstance(opts);
    return (0, _lodash.castArray)(data.data).map(entry => (0, _cleanData.cleanData)(entry, { ...ctx,
      contentTypeUid: uid
    }));
  } catch (error) {
    // reporter.panic(
    //   `Failed to fetch data from Strapi ${opts.url} with ${JSON.stringify(opts)}`,
    //   error,
    // );
    return [];
  }
};

exports.fetchEntity = fetchEntity;

const fetchEntities = async ({
  endpoint,
  queryParams,
  uid
}, ctx) => {
  const {
    strapiConfig,
    reporter
  } = ctx;
  const axiosInstance = (0, _axiosInstance.default)(strapiConfig);
  const opts = {
    method: 'GET',
    url: endpoint,
    params: queryParams,
    paramsSerializer: params => _qs.default.stringify(params, {
      encodeValuesOnly: true
    })
  };

  try {
    reporter.info(`Starting to fetch data from Strapi - ${opts.url} with ${JSON.stringify(opts.params)}`);
    const {
      data: {
        data,
        meta
      }
    } = await axiosInstance(opts);
    const page = parseInt(meta.pagination.page);
    const pagesToGet = Array.from({
      length: parseInt(meta.pagination.pageCount, 10) - page
    }).map((_, i) => i + page + 1);
    const arrayOfPromises = pagesToGet.map(page => {
      return (async () => {
        const options = { ...opts
        };
        options.params.pagination.page = page;
        reporter.info(`Starting to fetch data from Strapi - ${options.url} with ${JSON.stringify(opts.paramsSerializer(opts.params))}`);

        try {
          const {
            data: {
              data
            }
          } = await axiosInstance(options);
          return data;
        } catch (err) {
          reporter.panic(`Failed to fetch data from Strapi ${options.url}`, err);
        }
      })();
    });
    const results = await Promise.all(arrayOfPromises);
    const cleanedData = [...data, ...(0, _lodash.flattenDeep)(results)].map(entry => (0, _cleanData.cleanData)(entry, { ...ctx,
      contentTypeUid: uid
    }));
    return cleanedData;
  } catch (error) {
    reporter.panic(`Failed to fetch data from Strapi ${opts.url}`, error);
    return [];
  }
};

exports.fetchEntities = fetchEntities;